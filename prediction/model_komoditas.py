# -*- coding: utf-8 -*-
"""Model Komoditas.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZG4h1TY70I2gPbTxtSLhnCaWOePT2jgk
"""

import pandas as pd
import numpy as np
from sklearn.preprocessing import MinMaxScaler
from sklearn.model_selection import train_test_split
from tensorflow import keras
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout
import matplotlib.pyplot as plt
import joblib

dataSet = pd.read_csv('dataset_clean.csv')
df = pd.DataFrame(dataSet)
df['Tanggal'] = pd.to_datetime(df['Tanggal'])

print (df['Tanggal'])

# Memisahkan Input dan Output
input_features = ['BawangMerah', 'BawangPutihBonggol', 'BerasMedium', 'BerasPremium', 'CabaiMerahKeriting', 'CabaiRawitMerah', 'DagingAyamRas', 'DagingSapiMurni', 'GulaKonsumsi', 'MinyakGorengKemasanSederhana', 'TelurAyamRas']
output_features = ['BawangMerah', 'BawangPutihBonggol', 'BerasMedium', 'BerasPremium', 'CabaiMerahKeriting', 'CabaiRawitMerah', 'DagingAyamRas', 'DagingSapiMurni', 'GulaKonsumsi', 'MinyakGorengKemasanSederhana', 'TelurAyamRas']

x = df[input_features].values
y = df[output_features].values

print(df['Tanggal'])

scaler = MinMaxScaler()
x_scaled = scaler.fit_transform(x)
y_scaled = scaler.fit_transform(y)

print(x_scaled)

x_train, x_test, y_train, y_test = train_test_split(x_scaled, y_scaled, test_size=0.2, shuffle=False)

timesteps = 30 #data 30 hari untuk input
n_features_input = len(input_features)
n_features_output = len(output_features)

def create_sequences(x,y, time_steps) :
  x_seq, y_seq = [], []

  for i in range(len(x) - time_steps) :
    x_seq.append(x[i:i+timesteps])
    y_seq.append(y[i+timesteps])

  return np.array(x_seq), np.array(y_seq)

x_train_seq, y_train_seq = create_sequences(x_train, y_train, timesteps)
x_test_seq, y_test_seq = create_sequences(x_test, y_test, timesteps)

# dates_test_seq = dates_test_full[timesteps:]

model = Sequential()
model.add(LSTM(60, input_shape=(timesteps, n_features_input), return_sequences=True))
# model.add(Dropout(0.2)) #jika dibutuhkan untuk mencegah terjadinya Overfitting
model.add(LSTM(60))
model.add(Dense(n_features_output))

model.compile(loss='mean_absolute_error', optimizer='adam')

hist = model.fit(x_train_seq, y_train_seq, epochs=100, batch_size=32, verbose=1)

model_history = hist.history
loss = model_history['loss']

plt.figure()
plt.plot(loss, label='Loss')
plt.title('Mean Absolute Error (MAE)')
plt.show()

predictions = model.predict(x_test_seq)

predictions = scaler.inverse_transform(predictions)

y_test_asli = scaler.inverse_transform(y_test_seq)

mae = np.mean(np.abs(predictions - y_test_asli), axis=0)

for i, features in enumerate(output_features):
    print(f"MAE for {features}: {mae[i]}")

threshold_mae_BawangMerah = (df['BawangMerah'].max() - df['BawangMerah'].min()) * 10/100
threshold_mae_BawangPutihBonggol = (df['BawangPutihBonggol'].max() - df['BawangPutihBonggol'].min()) * 10/100
threshold_mae_BerasMedium = (df['BerasMedium'].max() - df['BerasMedium'].min()) * 10/100
threshold_mae_BerasPremium = (df['BerasPremium'].max() - df['BerasPremium'].min()) * 10/100
threshold_mae_CabaiMerahKeriting = (df['CabaiMerahKeriting'].max() - df['CabaiMerahKeriting'].min()) * 10/100
threshold_mae_CabaiRawitMerah = (df['CabaiRawitMerah'].max() - df['CabaiRawitMerah'].min()) * 10/100
threshold_mae_DagingAyamRas = (df['DagingAyamRas'].max() - df['DagingAyamRas'].min()) * 10/100
threshold_mae_DagingSapiMurni = (df['DagingSapiMurni'].max() - df['DagingSapiMurni'].min()) * 10/100
threshold_mae_GulaKonsumsi = (df['GulaKonsumsi'].max() - df['GulaKonsumsi'].min()) * 10/100
threshold_mae_MinyakGorengKemasanSederhana = (df['MinyakGorengKemasanSederhana'].max() - df['MinyakGorengKemasanSederhana'].min()) * 10/100
threshold_mae_TelurAyamRas = (df['TelurAyamRas'].max() - df['TelurAyamRas'].min()) * 10/100

print("threshold_mae_BawangMerah :", threshold_mae_BawangMerah)
print("threshold_mae_BawangPutihBonggol :", threshold_mae_BawangPutihBonggol)
print("threshold_mae_BerasMedium :", threshold_mae_BerasMedium)
print("threshold_mae_BerasPremium :", threshold_mae_BerasPremium)
print("threshold_mae_CabaiMerahKeriting :", threshold_mae_CabaiMerahKeriting)
print("threshold_mae_CabaiRawitMerah :", threshold_mae_CabaiRawitMerah)
print("threshold_mae_DagingAyamRas :", threshold_mae_DagingAyamRas)
print("threshold_mae_DagingSapiMurni :", threshold_mae_DagingSapiMurni)
print("threshold_mae_GulaKonsumsi :", threshold_mae_GulaKonsumsi)
print("threshold_mae_MinyakGorengKemasanSederhana :", threshold_mae_MinyakGorengKemasanSederhana)
print("threshold_mae_TelurAyamRas :", threshold_mae_TelurAyamRas)

target_index = 0

plt.figure(figsize=(10, 5))
plt.plot(y_test_asli[:,target_index], label ="Data Aktual")
plt.plot(predictions[:,target_index], label ="Data Prediksi")
plt.xlabel("Index")
plt.ylabel(output_features[target_index])
plt.title("Bawang Merah")
plt.legend()
plt.show()


# target_index = 0

# plt.figure(figsize=(10, 5))
# # Use the adjusted dates for the x-axis
# plt.plot(dates_test_seq, y_test_asli[:,target_index], label ="Data Aktual")
# plt.plot(dates_test_seq, predictions[:,target_index], label ="Data Prediksi")
# plt.xlabel("Tanggal") # Change the label to reflect that the x-axis is now date
# plt.ylabel(output_features[target_index])
# plt.title(output_features[target_index]) # Use the actual feature name
# plt.legend()
# plt.show()

target_index = 1

plt.figure(figsize=(10, 5))
plt.plot(y_test_asli[:,target_index], label ="Data Aktual")
plt.plot(predictions[:,target_index], label ="Data Prediksi")
plt.xlabel("Index")
plt.ylabel(output_features[target_index])
plt.title("Bawang Putih Bonggol")
plt.legend()
plt.show()


# target_index = 2

# plt.figure(figsize=(10, 5))
# # Use the adjusted dates for the x-axis
# plt.plot(dates_test_seq, y_test_asli[:,target_index], label ="Data Aktual")
# plt.plot(dates_test_seq, predictions[:,target_index], label ="Data Prediksi")
# plt.xlabel("Tanggal") # Change the label to reflect that the x-axis is now date
# plt.ylabel(output_features[target_index])
# plt.title(output_features[target_index]) # Use the actual feature name
# plt.legend()
# plt.show()

# Pilih satu fitur output yang ingin diprediksi
target_output_feature = 'BawangMerah'

# Temukan indeks dari fitur output yang dipilih
target_output_index = output_features.index(target_output_feature)

# Sesuaikan scaling untuk output (jika perlu, tetapi scaler yang ada bisa digunakan)
# Jika Anda ingin scaler yang spesifik untuk satu output, Anda perlu membuat scaler baru
# Misalnya: scaler_bawang_merah = MinMaxScaler().fit(df[[target_output_feature]].values)
# Namun, untuk saat ini kita akan tetap menggunakan scaler yang ada yang sudah fit pada semua output

# Sesuaikan model output (Opsional, jika ingin model yang hanya memprediksi 1 output)
# Jika model Anda sudah dilatih untuk banyak output, Anda bisa tetap menggunakannya
# dan hanya mengambil output yang diinginkan. Jika ingin melatih model baru khusus
# untuk 1 output, layer Dense terakhir perlu diubah:
# model_single_output = Sequential()
# model_single_output.add(LSTM(60, input_shape=(timesteps, n_features_input), return_sequences=True))
# model_single_output.add(LSTM(60))
# model_single_output.add(Dense(1)) # Hanya 1 unit untuk 1 output

# Karena model Anda sudah dilatih, kita akan menggunakan model yang sudah ada
# dan hanya mengambil output untuk fitur yang diinginkan.

# --- Bagian Prediksi (Multi-step forecasting) ---

# Ambil data historis terakhir sebanyak timesteps dari dataframe df
current_input_data = df[input_features].tail(timesteps).values

# Dapatkan tanggal terakhir dari dataframe df
last_date_in_df = df['Tanggal'].iloc[-1]

# Tentukan tanggal target untuk prediksi
tanggal_target_str = '2026-12-31' # Ganti dengan tanggal target yang diinginkan
tanggal_target = pd.to_datetime(tanggal_target_str)

# Inisialisasi list untuk menyimpan hasil prediksi di masa depan (hanya untuk fitur target)
future_predictions_single_feature = []
future_prediction_dates = [] # Untuk menyimpan tanggal prediksi

# Inisialisasi tanggal prediksi saat ini
current_predicted_date = last_date_in_df + timedelta(days=1)

print(f"Melakukan prediksi harga {target_output_feature} hingga tanggal {tanggal_target_str} dimulai dari tanggal setelah data terakhir ({last_date_in_df.strftime('%Y-%m-%d')})...")

# Lakukan prediksi iteratif hingga mencapai tanggal target
while current_predicted_date <= tanggal_target:
    # Pre-process current_input_data
    current_input_scaled = scaler.transform(current_input_data)
    current_input_seq = np.array([current_input_scaled])

    # Lakukan prediksi satu langkah ke depan
    next_step_prediction_scaled = model.predict(current_input_seq)

    # Ambil hasil prediksi hanya untuk fitur output yang ditargetkan
    next_step_prediction_single_feature_scaled = next_step_prediction_scaled[0, target_output_index].reshape(1, 1)

    # Inverse transform prediksi (gunakan scaler yang sama yang fit pada semua output)
    # Untuk inverse transform satu nilai, Anda perlu melakukan beberapa trik
    # karena scaler fit pada multi-dimensi. Cara yang umum adalah membuat array
    # dengan dimensi yang sesuai dan mengisi hanya nilai yang relevan.
    dummy_array = np.zeros((1, n_features_output))
    dummy_array[0, target_output_index] = next_step_prediction_scaled[0, target_output_index]
    next_step_prediction_asli_full = scaler.inverse_transform(dummy_array)
    next_step_prediction_asli_single_feature = next_step_prediction_asli_full[0, target_output_index]

    # Simpan hasil prediksi dan tanggalnya
    future_predictions_single_feature.append(next_step_prediction_asli_single_feature)
    future_prediction_dates.append(current_predicted_date)

    # Siapkan input untuk langkah berikutnya
    # Untuk input berikutnya, kita masih perlu menggunakan semua fitur input.
    # Bagian ini tetap sama. Kita mengganti data terlama dengan data terbaru (hasil prediksi).
    current_input_data = np.delete(current_input_data, 0, axis=0)
    # Tambahkan hasil prediksi untuk semua fitur output (karena ini yang akan menjadi input)
    # Jadi, meskipun kita hanya menampilkan 1 output, input untuk langkah selanjutnya
    # tetap menggunakan semua output yang diprediksi oleh model.
    current_input_data = np.vstack([current_input_data, next_step_prediction_asli_full[0]])

    # Tingkatkan tanggal prediksi
    current_predicted_date += timedelta(days=1)

# Tampilkan hasil prediksi
print(f"\nHasil Prediksi Harga {target_output_feature} untuk Hari-Hari Mendatang:")
for i in range(len(future_prediction_dates)):
    date = future_prediction_dates[i].strftime('%Y-%m-%d')
    price = future_predictions_single_feature[i]
    print(f"Tanggal: {date}, {target_output_feature}: {price:.2f}")

# Anda juga bisa membuat DataFrame hanya untuk fitur target
future_predictions_single_feature_df = pd.DataFrame({
    'Tanggal': future_prediction_dates,
    target_output_feature: future_predictions_single_feature
})
print(f"\nHasil Prediksi {target_output_feature} dalam bentuk DataFrame:")
print(future_predictions_single_feature_df)